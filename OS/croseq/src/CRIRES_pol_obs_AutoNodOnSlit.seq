# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# E.S.O. - VLT project
#
# "@(#) $Id: CRIRES_pol_obs_AutoNodOnSlit.seq 315705 2018-11-07 16:16:04Z ccumani $"
#
# who       when        what
# --------  ----------  -------------------------------------------------------
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#   NAME
#   CRIRES_pol_obs_AutoNodOnSlit - Spectropolarimetry
#
#   DESCRIPTION
#   ..
#
#   SEQUENCE
#   1. i) instrument is set up according to acquisition
#     ii) then set up instrument according to optical configuration using P2PP parameters
#         as above
#   2. DPR keywords:
#      DPR.CATG = SCIENCE
#      DPR.TYPE = OBJECT
#
#      - Staring: DPR.TECH =SPECTRUM, DIRECT, OTHER
#        -> SEQ.NABCYCLES = 0,SEQ.JITTER.WIDTH=0
#      - Jittered staring: DPR.TECH =SPECTRUM, DIRECT, JITTER
#        -> SEQ.NABCYCLES = 0,SEQ.JITTER.WIDTH>0
#      - Nodding: DPR.TECH =SPECTRUM, NODDING, OTHER
#        -> SEQ.NABCYCLES > 0,SEQ.JITTER.WIDTH=0
#      - Jittered, nodding: DPR.TECH =SPECTRUM, NODDING, JITTER
#        -> SEQ.NABCYCLES > 0,SEQ.JITTER.WIDTH >0
#   3. perform observing sequence exactly following:
#      ISAAC spec obs AutoNodOnSlit
#
#   SEE ALSO
#   crlibTpl(3), BobTPL(n), tplOBS(3), tplIRACE(3)
#   VLT-SPE-ESO-14500-3485, Issue 1, Date 07.07.06
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

proc CRIRES_pol_obs_AutoNodOnSlit { } {

    tplNew croseqOS os
    croseqTPL_POLNOD tpl

    tpl Execute

    return ""
}


#---------------------------------------------------------------------------
# class croseqTPL_AUTONODONSLIT
#
global croseqClass
catch { delete class $croseqClass }
set croseqClass "croseqTPL_POLNOD"
class croseqTPL_POLNOD {

    #-----------------------------------------------------------------------
    # Execute template
    #
    public method Execute {} {
	seeBobVars

	# execute main part of the template
	Begin
	tplTry {
	    Main
	} {
	    # return to initial target position
            Cleanup $SEQ(RETURN)
	    # wait for all exposures to be archived properly
	    if { $expsDone } { os Wait "-all" }
	}
    }


    #-----------------------------------------------------------------------
    # Main - Main template proc
    #
    protected method Main {} {
	seeBobVars

	set nAB          $SEQ(NABCYCLES)
	# number of exposures per offset position
	set nexpo        $SEQ(NEXPO)
	set nodThrow     $SEQ(NODTHROW)
	set nodDelay     $SEQ(NOD.DELAY)

	# total number of exposures: 2 exposures per AB cycles * n_exposures set by user * 4 polarimetric sub-exposures
	set TPL(NEXP) [expr {$nexpo * $nAB * 2 * 4 * }]

	# set DPR.TECH according to spec.
	set tech "SPECTRUM"
	if { $DPR(TYPE) == "WAVE" } {
	    set tech "SPECTRUM,NODDING"
	    if { $nodThrow == 0 || $nAB == 0  } {set tech "SPECTRUM,DIRECT"  }
	} elseif { $nAB == 0 } {
	    set tech "SPECTRUM,DIRECT,OTHER"
	} else {
	    if { $nodThrow == 0} {set tech "SPECTRUM,DIRECT,OTHER"}
	    if { $nodThrow >  0} {set tech "SPECTRUM,NODDING,OTHER"}
	}
	set DPR(TECH) $tech


	#---------------------------------------------------------------
	# Generate sequence list (list of tokens)
	#
	# Tokens:
	#   "S"   start
	#   "A"   position ('Object')
	#   "B"   position ('Sky')
	#   "P"   positive nod throw
	#   "N"   negative nod throw
	#

	# start: step half throw "P"
	set seqL "S"

	# generate sequence list (list of tokens)
	loop i 0 $nAB {
	    append seqL [expr {$i % 2 == 0 ? "ANB" : "BPA"}]
	}

	# if mode staring: at least 1 exposure (Object)
	if { $nAB == 0 } {
	    set TPL(NEXP) expr {$nexpo * 4}
	    set seqL "A"
	}

	#---------------------------------------------------------------
	#
	set insMode "INS.MODE $TPL(MODE)"


  loop i 0 [string length $seqL] {
		checkAbortFlag

		# current token from sequence string
		set tok [string index $seqL $i]

		#--------------------------------------------------------------------
		# For exposures add FITS keys
		#
		if { "$tok" == "A" || "$tok" == "B" } {

	    lassign [CumOffset $sumOffset_] px py
	    set fits "\
			SEQ.NODTHROW     $nodThrow \
			SEQ.NABCYCLES    $nAB \
			SEQ.CUMOFFSETX   $px \
			SEQ.CUMOFFSETY   $py \
			SEQ.NODPOS       $tok"
		}

		#--------------------------------------------------------------------
		# The current token determines the action
		#
		switch $tok {
		    "A" {
          loop i 0 $nexpo {
            # [TODO] move the decker into the right position for A-pos nodding (maybe in acquisition template?)
            # [TODO] set the right beamsplitter angle. if linear: set tracking, set derotator
            Expose $tok 1 $fits
            # [TODO] rotate beam-splitter +180 degrees
            Expose $tok 1 $fits
            Expose $tok 1 $fits
            # [TODO] rotate -180 degrees
            Expose $tok 1 $fits
          } #end of nexpo loop
		    } # end of "A" case loop

        "B" {
          loop i 0 $nexpo {
            # [TODO] move the decker into the right position for B-pos nodding (maybe in acquisition template?)
            # [TODO] set the right beamsplitter angle. if linear: set tracking, set derotator
            Expose $tok 1 $fits
            # [TODO] rotate beam-splitter +180 degrees
            Expose $tok 1 $fits
            Expose $tok 1 $fits
            # [TODO] rotate -180 degrees
            Expose $tok 1 $fits
          } #end of nexpo loop
		    } # end of "B" case loop

		    "P" {
			# positive nod throw (combined offset)
			OffsetAlongSlit $tok [$nodThrow]
			# nodding delay
			os Uif Sleep $nodDelay
		    }

		    "N" {
			# negative nod throw (combined offset back)
			OffsetAlongSlit $tok [expr {0.0 - $nodThrow}]
			# nodding delay
			os Uif Sleep $nodDelay
		    }

		    "S" {
			OffsetAlongSlit $tok [expr {$nodThrow / 2.0}]
			# nodding delay
			os Uif Sleep $nodDelay
		    }

		    default {
			error "Unknown token '$tok'"
		    }
		}
	    }

	    # move back to the origin before starting next loop
    } # end method main


    #-----------------------------------------------------------------------
    # OffsetAlongSlit - combined offset along the slit
    #
    protected method OffsetAlongSlit { tok offset } {
	if { $offset == 0 } {return}

	#= 1. convert offset along the slit in Alpha,Delta offset
	tplLog "Offsetting along the slit ...: [format %.3f $offset] (arcsec)"
	set angleOnSky [os GetAngleOnSky]
	set angleOnSky [expr {$angleOnSky * atan(1) / 45.0}]
	set da [expr {-1.0 * $offset * sin($angleOnSky)}]
	set dd [expr {-1.0 * $offset * cos($angleOnSky)}]
	if { abs($da) < 0.0001 } { set da 0.0 }
	if { abs($dd) < 0.0001 } { set dd 0.0 }

	#= 2. perform offset
	os Offsadg $da $dd

	#= 4. update accumulated offset
	tplIncr sumOffset_ $offset
    }


    #-----------------------------------------------------------------------
    # Expose - run nrep exposures
    #
    protected method Expose { tok nrep fits } {
	seeBobVars
	tplLog "Position $tok ..." blue 0 LightYellow

	# foreach nexpo exposures:
	loop i 0 $nrep {
	    if { $expsDone } { os Wait "-all" }
	    tplLog ""
	    checkAbortFlag
	    os Setup "-function INS.MODE $TPL(MODE) OCS.DET1.IMGNAME [os ImgName]"
	    os AddFits $fits
	    os Start
	    set expsDone 1
	    os Wait "-cond CanStartNextObs"
	}
    }


    #-----------------------------------------------------------------------
    # Cleanup - cleanup before returning from template
    #
    protected method Cleanup { ret } {

	# if disabled by user: do nothing
	if { ! $ret } {return}

	# go back to initial position
	OffsetAlongSlit "C" [expr {0.0 - $sumOffset_}]
	set sumOffset_ 0.0
    }



    #-----------------------------------------------------------------------
    # constructor
    #
    constructor {} {
    	set scidet_ysecpix [os Cfg1 Get INS.SCIDET.YSECPIX]
    }

    ## included TCL-file ended here.

    #-----------------------------------------------------------------------
    # Begin
    #
    public method Begin {} {
	seeBobVars
	os Begin

        # ~~~~~~~~~~~~~~~~~~
        # Detector Setup (A)
        # ~~~~~~~~~~~~~~~~~~
        set det1setupA [os Dcs1 GenDet1SetupA $DET1(READ.CURNAME)]
	os Setup "-function $det1setupA"

	# ~~~~~~~~~~~~~~
	# SETUP and init
	# ~~~~~~~~~~~~~~

	# restore device positions (calibrations may have moved them)
	os ObsDevicesRestore

	# save SV guiding state
	set isGuiding [os IsGuiding]


	# if moving carriage, suspend AO loop
	set suspended 0
	set carrg [os GetMaccStatus "INS.OPTI1.NAME"]
	if { $carrg != $INS(OPTI1.NAME) && [os IsLoopClosed] } {
	    os Macao Suspend
	    set suspended 1
	}
	set carrg $INS(OPTI1.NAME)
	# also center the target star while AO loop is suspended
	os CenterTarget
	os Setup "-file $TPL(REFSUP) -function \
	    INS.MODE        $TPL(MODE) \
	    INS1.OPTI1.NAME $carrg \
	    INS.WLEN.CWLEN $INS(WLEN.CWLEN) \
	    [os Dcs1 GetIntTime]"
	if { $suspended } {
	    os Macao Resume
	}

	# close AO loop and enable SV guiding
	croseqAOLoopCheckAndClose
	os Setup "-function OCS.CON.EGUIDE $isGuiding"

	# send observing wavelength to the telescope
	checkAbortFlag
	os Tcs Setlam $INS(WLEN.CWLEN)

	# allow the user to adjust DIT and NDIT
	lassign [os Dcs1 GetIntTime] dummy1 dit dummy2 ndit
	lassign [os Uif AdjustDitNdit $dit $ndit] abort


	if { $abort } { ::bob::bobAbort }
	checkAbortFlag
    }


    #-----------------------------------------------------------------------
    # CumOffset - return SEQ.CUMOFFSETX/Y values
    #
    protected method CumOffset { sumOffset } {
	# accumulated position on the science detector
	set py [format "%.3f" [expr {$sumOffset / $scidet_ysecpix}]]
	return [list 0.0 $py]
    }

    #-----------------------------------------------------------------------
    # variables
    #
    protected variable scidet_ysecpix
    protected variable sumOffset_ 0.0
    protected variable expsDone 0
}
}


#
#___oOo___
