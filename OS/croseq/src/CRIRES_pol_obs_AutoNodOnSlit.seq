# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# E.S.O. - VLT project
#
# "@(#) $Id: CRIRES_pol_obs_AutoNodOnSlit.seq 321865 2019-05-20 13:51:49Z ccumani $"
#
# who       when        what
# --------  ----------  -------------------------------------------------------
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#   NAME
#   CRIRES_pol_obs_AutoNodOnSlit - Spectropolarimetry
#
#   DESCRIPTION
#   ..
#
#   SEQUENCE
#   1. i) instrument is set up according to acquisition
#     ii) then set up instrument according to optical configuration using P2PP parameters
#         as above
#   2. DPR keywords:
#      DPR.CATG = SCIENCE
#      DPR.TYPE = OBJECT
#
#      - Staring: DPR.TECH =SPECTRUM, DIRECT, OTHER
#        -> SEQ.NABCYCLES = 0,SEQ.JITTER.WIDTH=0
#      - Jittered staring: DPR.TECH =SPECTRUM, DIRECT, JITTER
#        -> SEQ.NABCYCLES = 0,SEQ.JITTER.WIDTH>0
#      - Nodding: DPR.TECH =SPECTRUM, NODDING, OTHER
#        -> SEQ.NABCYCLES > 0,SEQ.JITTER.WIDTH=0
#      - Jittered, nodding: DPR.TECH =SPECTRUM, NODDING, JITTER
#        -> SEQ.NABCYCLES > 0,SEQ.JITTER.WIDTH >0
#   3. perform observing sequence exactly following:
#      ISAAC spec obs AutoNodOnSlit
#
#   SEE ALSO
#   crlibTpl(3), BobTPL(n), tplOBS(3), tplIRACE(3)
#   VLT-SPE-ESO-14500-3485, Issue 1, Date 07.07.06
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

proc CRIRES_pol_obs_AutoNodOnSlit { } {

    tplNew croseqOS os
    croseqTPL_POLNOD tpl

    tpl Execute

    return ""
}

global croseqClass
catch { delete class $croseqClass }
set croseqClass "croseqTPL_POLNOD"

#---------------------------------------------------------------------------
# class croseqTPL_AUTONODONSLIT
#
#global croseqClass
#catch { delete class $croseqClass }
#set croseqClass "croseqTPL_POLNOD"
class croseqTPL_POLNOD {
    inherit croseqTPL_AUTONODONSLIT

    constructor {} {
    }

    # In the polarimetric case, the others parameter correspond
    protected method Expose { tok nrep fits {nodPos "NONE"}} {
        seeBobVars
        set wave [seq_dbReadSymbolic "<alias>WLEN.filt2" ]
        set posAng $INS(ROT.POSANG)
        set polMode $INS(POL.TYPE) 
	set bsIdx -1
	set rotAngle 0
	set dbAlias "NONE"

        if { $wave == "YJ" && $polMode == "CIRCULAR"} {
            set bsIdx 4
	    set derotatorMode "STAT"
	    set turretPos "YJ_circular"
	    set rotAngle 180
	    set dbAlias "<alias>POLC2"
        } elseif { $wave == "HK" && $polMode == "CIRCULAR"} {
            set bsIdx 3
	    set derotatorMode "STAT"
	    set turretPos "HK_circular"
	    set rotAngle 180
	    set dbAlias "<alias>POLC1"
        } elseif { $wave == "YJ" && $polMode == "LINEAR"} {
            set bsIdx 2
	    set derotatorMode "SKY"
	    set turretPos "YJ_linear"
	    set rotAngle 90
	    set dbAlias "<alias>POLL2"
        }  elseif { $wave == "HK" && $polMode == "LINEAR"} {
            set bsIdx 1
	    set derotatorMode "SKY"
	    set turretPos "HK_linear"
	    set rotAngle 90
	    set dbAlias "<alias>POLL1"
        } else {
	    error  "case wave $wave and polarimetric mode $polMode is not supported"
	}

        #TODO check that decker position are correct
	set deckerPos("A") "Dek13"
	set deckerPos("B") "Dek24"

        tplLog "polarisation mode: $polMode, wave: $wave, derotator mode: $derotatorMode"
        tplLog "Starting taking $SEQ(NEXPO) exposures for position $nodPos"

        # move the decker into the right position for the current nodding position
        tplLog "Moving decker to  $deckerPos("$nodPos")"
        os Setup "-function INS.OPTI8.NAME $deckerPos("$nodPos")"

	loop i 0 $SEQ(NEXPO) {
            
            # rotating the SPU motor
            os Setup "-function INS1.ROT5.NAME $turretPos"  

	    #rotatin beam-splitter and taking exposure
            # TODO : where do we get the offset from ?
            os Setup "-function INS1.ROT${bsIdx}.MODE $derotatorMode INS1.ROT${bsIdx}.POSANG $posAng" 
            ExposeOnce $fits
            # the rotation is done from the current Beam splitter position (only matters for linear case)
            set curAngle [seq_dbReadSymbolic "$dbAlias.status2"]
	    tplLog "Current position is $curAngle"
            os Setup "-function INS1.ROT${bsIdx}.MODE $derotatorMode INS1.ROT${bsIdx}.POSANG [expr $curAngle+$rotAngle]" 
            # Making sure that $dbAlias.status2 is updated after the rotation by $rotAngle
            tplLog "Current position is $curAngle"
            ExposeOnce $fits
            ExposeOnce $fits
            # we rotate backwards from the current beam splitter position (that only changes for the linear case)
            set curAngle [seq_dbReadSymbolic "$dbAlias.status2"]
            os Setup "-function INS1.ROT${bsIdx}.MODE $derotatorMode INS1.ROT${bsIdx}.POSANG [expr $curAngle-$rotAngle]" 
            tplLog "Current position is $curAngle"
            ExposeOnce $fits
	}
    }

    # getExposureNb returns the total number of exposures
    # n_AB = 0 is a special case: only pos A is exposed
    protected method getExposureNb { nexpo nAB numOuterLoop } {
        if {$nAB == 0} {
            return [expr {$nexpo * ($nAB + 1) * $numOuterLoop * 4}]
        } else {
            return [expr {$nexpo * $nAB * 2 * $numOuterLoop * 4}]
        }
    }

    #-----------------------------------------------------------------------
    # Expose - run nrep exposures
    #
    private method ExposeOnce { fits } {
	seeBobVars
	os Setup "-function INS.MODE $TPL(MODE) OCS.DET1.IMGNAME [os ImgName]"
	os AddFits $fits
	os Start
	os Wait "-cond CanStartNextObs"
    }


}


#
#___oOo___
